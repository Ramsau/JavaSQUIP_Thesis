\documentclass[11pt,
  titlepage=false,
  %parskip=half,      % enable if you want paragraphs separated by vertical spacing instead of indents
]{scrreprt}

% Style settings
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\addtokomafont{disposition}{\rmfamily}

% Hack chapter layout - don't use in other papers!
\usepackage{etoolbox}
\makeatletter\patchcmd{\scr@startchapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}\makeatother

% Useful packages for complex content:
\usepackage{amsmath,amsfonts,amssymb} % typesetting math
%\usepackage{siunitx}                 % typesetting SI-units and formatted numbers
%\usepackage{listings}                % typesetting source code
\usepackage{booktabs,multirow}        % utils for complex/beautiful tables
%\usepackage{subcaption}              % placing multiple subfigures in a figure
%\usepackage{graphicx}                % including external image files
%\usepackage{tikz}                    % drawing figures within LaTeX

% Bibliography, referencing, and indexing
\usepackage{csquotes}                 % typesetting \enquote{text in quotes} correctly
\usepackage[backend=biber,
            style=alphabetic,
            minalphanames=3, maxalphanames=4,
            maxbibnames=20]{biblatex} % to generate the bibliography
\addbibresource{report.bib}           % name of the bib-file
\addbibresource{main.bib}

% Useful utils:
%\usepackage{todonotes}               % add ToDo markers (\todo{...}, \todo[inline]{...})
\usepackage[hidelinks]{hyperref}
\usepackage{textcomp}      % clickable links (but hide color frames around links)
%\usepackage{cleveref}                % named references (\Cref{chap:introduction}, ...)

% Your own macros:
%\newcommand{\mynewmacro}[1]{my content with one input parameter: #1}


\begin{document}

%--- FRONT MATTER --------------------------------------------------------------

\title{JavaSQIP}
\subtitle{An application of a scheduler queue-based covert channel to JavaScript}
\author{Christoph Royer}
\date{Introduction to Scientific Working 2022/23\bigskip\bigskip}
\publishers{\normalsize
  Supervisor:
  Stefan Gast
  \medskip\par
  Institute of Applied Information Processing and Communications\\
  Graz University of Technology
}


\maketitle

\chapter*{\centering\Large Abstract}
The implementation of out-of-order execution has brought a big performance benefit to current CPUs.
But with this benefit come also security concerns, since attackers can exploit the timing variations which are bound to occur in an out-of-order pipeline.
Attacks which target only one execution unit through a separate scheduler queue -- as seen in the Apple M1 and AMD Zen 2 and Zen 3 microarchitectures -- have proven even more powerful than port contention on single-scheduler systems.
As with any attack, porting this side channel to the web would greatly increase its reach and number of victims.

In this paper, we present the JavaSQUIP attack, which is a port of SQUIP~\cite{squip} to JavaScript.
We look into the security measures used in common browsers to prevent timing attacks, and show how we worked around them successfully.
Our covert channel can provide communication across separate browser instances at a speed of 1000 bits/s, which is faster than any current covert channel of this type.

JavaSQUIP makes it clear that current browsers have not yet been able to adapt to be secure in light of the ever increasing complexity of modern CPUs.
Our findings suggest that making these attacks impossible may not even be feasible because the drawbacks in performance and features would be too large.


\paragraph{Keywords:}
Covert channel $\cdot$
Single-queue port contention $\cdot$
JavaScript $\cdot$
AMD Zen

\clearpage


%--- INTRODUCTION --------------------------------------------------------------

\chapter{Introduction}
\label{ch:introduction}

Nowadays, CPU manufacturers are in a lasting battle against each other to make their product faster and faster.
One of the ways this is achieved is out-of-order execution, where instructions are not executed in the order given by the binary, but rather as soon as their respective dependencies are ready.
This toes the line of breaking the hardware-software contract, and though it is ensured that the program is executed correctly, security suffers under this shortcut.

By measuring the variation in speed-up gained from out-of-order execution, an attacker can gain insight into sensitive information.
One of the ways attacks achieve this is through port contention.
Because the instructions are reordered on the fly, the CPUs scheduler needs to distribute incoming instructions across the ports for its several specialized execution units.
If the attacker is co-located with the victim on the same core, the attacker can issue instructions for a particular execution unit and check whether they get delayed or not.
This then tells the attacker whether victim is using an execution unit in that port or not.
SMoTherSpectre~\cite{Bhattacharyya2019} and PortSmash~\cite{Aldaya2019port} already use this principle successfully.

While SMoTherSpectre relies on an architecture where there is only one scheduler for all ports, SQUIP~\cite{squip} focuses on CPUs with separate scheduler queues per execution unit.
Because each execution unit has its own scheduler, pipeline stalls are easier to achieve and allow more accurate measurements.
This exploitation of \textit{per-execution-unit port contention} makes SQUIP a fast and reliable covert channel on many modern CPU architectures such as the Apple M1, and the AMD Zen 2 and Zen 3.

Since implementations of port contention-based side channels in a browser setting already exist~\cite{Rokicki2022webport}, we ask the following research question:

\textit{Can per-execution-unit scheduler port contention be exploited in a browser setting? Are there significant benefits compared to single scheduler port contention-based approaches?}

In this paper, we present JavaSQUIP, a browser-based covert channel using the SQUIP attack.
We show that it is reliable and faster than approaches based on CPU architectures with a single scheduler queue.
We develop a framework for transmitting data between separate instances of a browser at speeds of up to 1000 bit/s.

\paragraph{Outline.}
In Section~\ref{ch:background}, we explain the relevant knowledge around pipelines, schedulers and port contention.
We also observe several challenges that come with trying to implement a timing attack in a browser.
Section~\ref{ch:implementation} shows how we dealt with these challenges.
Section~\ref{ch:conclusion} concludes by comparing JavaSQUIP's performance to similar attacks and outlining potential use cases.


%--- BACKGROUND ----------------------------------------------------------------

\chapter{Background}
\label{ch:background}

In this chapter, we go into detail on CPU scheduling and how it has been exploited in the past.
Afterwards, we take a closer look into the browser features needed to implement these exploits in JavaScript.

\section{CPU Scheduling}
\label{sec:cpuschedulers}
For performance reasons, modern CPUs use efficiency features at almost every level of the lifecycle of an instruction.
In the following, we will list these features for each of the stages along with the way they are exploitable.

\textbf{Fetch.}
Before an instruction can be used, it needs to be loaded from cache or memory.
As branches can make loading unpredictable and loading the wrong instruction is expensive, a \textit{branch prediction unit} tries to guess which path is more likely to be loaded.
Taking this one step further, the predicted path may also be executed before the condition for the branch has been computed.
This is called \textit{speculative execution}, and it can be exploited, as was shown in the Spectre~\cite{spKocherHFGGHHLM019} attack.

\textbf{Decode.}
Modern CPUs divide normal instructions -- also called \textit{macro-ops} -- into smaller, RISC-like instructions;
these are called \textit{micro-ops} (\textmu ops).
These \textmu ops can be distributed across specialized execution units, enabling more fine-grained control and thus an increased speed.

% TODO accurate?
\textbf{Schedule/Execute.}
Once created, the \textmu ops are queued to be executed out of order as soon as their dependencies are met.
Depending on the CPU micoarchitecture, there can be one scheduler queue for every execution unit, or multiple -- one for each (group of) execution unit(s).
On CPUs that support simultaneous multithreading (SMT), an attacker may be co-located with the victim on the same core.
This opens up the vulnerability of a timing attack based on port contention;
an attacker can find out whether the victim is executing a particular \textmu op based on timing differences in the scheduler queue.
To achieve this, the attacker fills up the scheduler queue to the point that it is almost full;
any activity of the victim that involves this scheduler queue will overflow the queue, leading to a queue stall.
The attacker can measure this easily because it entails a significant spike in execution time in the affected queue.
SMoTherSpectre~\cite{Bhattacharyya2019} and PortSmash~\cite{Aldaya2019port} implement this attack in an environment with a single scheduler queue.
SQUIP~\cite{squip} adapts the exploit to architectures with multiple scheduler queues.

\textbf{Retire.}
After all the \textmu ops of a macro-operation have completed, the \textit{retire control unit} (RCU) reassembles the results.
These are then passed on to the frontend -- the dissection into \textmu ops is transparent to the user.

The JavaSQUIP attack focuses on scheduler queue contention.
While a port contention-based side channel of single-scheduler based CPUs has been implemented in JavaScript~\cite{Rokicki2022webport},
JavaSQUIP does the same for multi-scheduler architectures.

\section{Browser security measures}
\label{sec:browsersecurity}
Since the advent of many timing side- and covert channels~\cite{spKocherHFGGHHLM019, Bhattacharyya2019, Rokicki2022webport}, browser developers have devised many measures to mitigate the threat~\cite{shusterman2021prime}.
This has always meant striking a balance between security and efficiency.
Because of this, many potential attack surfaces cannot be eliminated without unreasonable losses in performance, though  some measures do slow down side- and covert channels significantly.

In the following we expand on security measures regarding multithreading and accurate timing in browsers, as both are needed to mount the SQUIP attack.

\subsection{Multithreading}\label{subsec:multithreading}
Though JavaScript does not support low-level control over threading, the \texttt{Web Workers} API~\cite{webworkers} allows the user to create workers running in a separate thread.
An instantiated worker runs a predefined script.
The main thread can interface with the worker via calls to the \texttt{Worker.postMessage()} function and via a \texttt{SharedArrayBuffer}~\cite{sharedarraybuffer}.
Creating a \texttt{SharedArrayBuffer} was restricted to SSL-secured browser windows, which is not a problem for this attack.

% TODO should this go to main?
For co-locating the receiver with the sender, the receiver creates as many workers as the number of cores on the machine's CPU.
Now, every one of these workers will create a lot of entries in a particular execution unit's queue.
This makes it very likely that each of the workers will be moved to a separate core to reduce port contention.
Since every worker is in a separate core, one of them is bound to be co-located on the same core with the sending thread.

\subsection{Accurate timing}\label{subsec:accurate-timing}
JavaSQUIP needs two kinds of timing in order to work properly:
\begin{itemize}
    \item a cross-browser syncronized clock to determine the start of bit transmissions:

    on the order of $f_{transmission}^{-1} \approx$ 1ms
    \item a fine-grained measurement to measure port contention:

    on the order of 100 CPU cycles $\approx$ 25ns
\end{itemize}

The synchronisation can be realized with the \texttt{Date.now()}~\cite{datenow} function, which gives a synchronized Unix timestamp with millisecond accuracy.
This method only works for transmissions of up to 1000 bits/s, since there is no more precise timestamp in JavaScript which is synchronized across browser instances.

% TODO: does this belong in main?
% TODO: source for manchester code
To get around this and realize a faster transmission than 1000 bits/s, we propose implementing the Manchester Code \textbf{[citation needed]}.
It is self-synchronizing, which eliminates the need for an external source of synchronisation.
The actual implementation is not within the scope of this paper.

The receiver also needs a way to measure the small variations in timing whenever a scheduler queue gets blocked.
Since timing attacks need accurate timing to work, browser developers are restricting the accuracy of timing sources that are available to the user.
At the time of writing this, no common browser provides the user with a timing source with more accuracy than 1 ms.

% TODO: does this belong in main?
Nevertheless, an attacker can produce their own timing source.
We can instantiate a counting worker, which continually increases one variable in the \texttt{SharedArrayBuffer}.
The other receiver workers can then access this counter and use it to measure execution times with adequate accuracy.

\subsection{Low-level operations in JavaScript}\label{subsec:lowleveljs}
A port-contention covert channel works best if the issued \textmu op only fills up one scheduler queue.
For example, AMD Zen, Zen2, and Zen3 architectures support multiplication only on ALU1 \textbf{[citation needed]}.
By sending multiple codependent \texttt{imul} instructions, we can fill ALU1's scheduler queue.

JavaScript handles numbers as floats by default.
This means that a simple invocation of a multiplication like \texttt{a * b;} will not result in an \texttt{imul} instruction on the CPU.
Rather, \texttt{Math.imul(a, b)} \textbf{[citation needed]} does exactly what we need:
It interprets the parameters as 32bit integers and multiplies them as such, filling up ALU1's scheduler queue.


%--- IMPLEMENTATION ----------------------------------------------------------------
\chapter{Implementing JavaSQUIP}
\label{ch:implementation}

%--- CONCLUSION ----------------------------------------------------------------

\chapter{Conclusion}
\label{ch:conclusion}
% TODO: should i conclude about the experiment or the literary study?
In this paper, we ported the SQUIP~\cite{squip} attack to a JavaScript context, thus creating the JavaSQUIP covert channel.
JavaSQUIP has achieved a transmission rate of 1000 bits/s, proving an advantage in performance over attacking single-scheduler based architectures~\cite{Rokicki2022webport}.
This shows that architectures with multiple scheduler queues present a bigger attack surface than their single-scheduler counterparts.

JavaSQUIP breaks the sandboxing model of a web browser context.
This means that one browser instance can communicate with another without using the network, thus being virtually undetectable for an unknowing victim.
This could potentially be used by malicious code within a website -- no matter its origin -- to exfiltrate data to another browser instance on the same computer.

Though security updates in modern browsers slow down and hinder timing attacks, microarchitectural attacks have not yet been eliminated.
JavaSQUIP mostly uses JavaScript features that have already been restricted to improve security as much as feasible;
Mitigating microarchitectural attacks in a browser setting proves to be increasingly hard as CPUs grow more and more complex.


%--- BIBLIOGRAPHY --------------------------------------------------------------

\printbibliography

\end{document}
